--- linux-2.4.19/drivers/net/ppp_generic.c.orig	Mon May 12 01:36:31 2003
+++ linux-2.4.19/drivers/net/ppp_generic.c	Mon May 12 03:09:13 2003
@@ -99,6 +99,7 @@
 	spinlock_t	rlock;		/* lock for receive side 58 */
 	spinlock_t	wlock;		/* lock for transmit side 5c */
 	int		mru;		/* max receive unit 60 */
+	int		mru_alloc;	/* MAX(1500,MRU) for dev_alloc_skb() */
 	unsigned int	flags;		/* control bits 64 */
 	unsigned int	xstate;		/* transmit state bits 68 */
 	unsigned int	rstate;		/* receive state bits 6c */
@@ -126,6 +127,7 @@
 	struct sock_fprog pass_filter;	/* filter for packets to pass */
 	struct sock_fprog active_filter;/* filter for pkts to reset idle */
 #endif /* CONFIG_PPP_FILTER */
+	int		opad;		/* ECP or CCP (MPPE) output padding */
 };
 
 /*
@@ -531,6 +533,8 @@
 		if (get_user(val, (int *) arg))
 			break;
-		ppp->mru = val;
+		ppp->mru_alloc = ppp->mru = val;
+		if (ppp->mru_alloc < PPP_MRU)
+		    ppp->mru_alloc = PPP_MRU;	/* increase for broken peers */
 		err = 0;
 		break;
 
@@ -1006,8 +1010,8 @@
 	/* try to do packet compression */
 	if ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state != 0
 	    && proto != PPP_LCP && proto != PPP_CCP) {
-		new_skb = alloc_skb(ppp->dev->mtu + ppp->dev->hard_header_len,
-				    GFP_ATOMIC);
+		new_skb = alloc_skb(ppp->dev->mtu + ppp->dev->hard_header_len
+				    + ppp->opad, GFP_ATOMIC);
 		if (new_skb == 0) {
 			printk(KERN_ERR "PPP: no memory (comp pkt)\n");
 			goto drop;
@@ -1019,15 +1023,28 @@
 		/* compressor still expects A/C bytes in hdr */
 		len = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,
 					   new_skb->data, skb->len + 2,
-					   ppp->dev->mtu + PPP_HDRLEN);
+					   ppp->dev->mtu + ppp->opad
+					   + PPP_HDRLEN);
 		if (len > 0 && (ppp->flags & SC_CCP_UP)) {
 			kfree_skb(skb);
 			skb = new_skb;
 			skb_put(skb, len);
 			skb_pull(skb, 2);	/* pull off A/C bytes */
-		} else {
+		} else if (len == 0) {
 			/* didn't compress, or CCP not up yet */
 			kfree_skb(new_skb);
+		} else {
+			/*
+			 * (len < 0)
+			 * MPPE requires that we do not send unencrypted
+			 * frames.  The compressor will return -1 if we
+			 * should drop the frame.  We cannot simply test
+			 * the compress_proto because MPPE and MPPC share
+			 * the same number.
+			 */
+			printk(KERN_ERR "ppp: compressor dropped pkt\n");
+			kfree_skb(new_skb);
+			goto drop;
 		}
 	}
 
@@ -1515,14 +1532,15 @@
 	int len;
 
 	if (proto == PPP_COMP) {
-		ns = dev_alloc_skb(ppp->mru + PPP_HDRLEN);
+		ns = dev_alloc_skb(ppp->mru_alloc + PPP_HDRLEN);
 		if (ns == 0) {
 			printk(KERN_ERR "ppp_decompress_frame: no memory\n");
 			goto err;
 		}
 		/* the decompressor still expects the A/C bytes in the hdr */
 		len = ppp->rcomp->decompress(ppp->rc_state, skb->data - 2,
-				skb->len + 2, ns->data, ppp->mru + PPP_HDRLEN);
+				skb->len + 2, ns->data,
+				ppp->mru_alloc + PPP_HDRLEN);
 		if (len < 0) {
 			/* Pass the compressed frame to pppd as an
 			   error indication. */
@@ -1949,6 +1967,20 @@
 			ppp_xmit_unlock(ppp);
 			err = 0;
 		}
+		if (ccp_option[0] == CI_MPPE)
+			/*
+			 * pppd (userland) has reduced the MTU by MPPE_PAD,
+			 * to accomodate "compressor" growth.  We must
+			 * increase the space allocated for compressor
+			 * output in ppp_send_frame() accordingly.  Note
+			 * that from a purist's view, it may be more correct
+			 * to require multilink and fragment large packets,
+			 * but that seems inefficient compared to this
+			 * little trick.
+			 */
+			ppp->opad = MPPE_PAD;
+		else
+			ppp->opad = 0;
 
 	} else {
 		ppp_recv_lock(ppp);
@@ -2229,6 +2261,7 @@
 
 	ppp->file.index = unit;
 	ppp->mru = PPP_MRU;
+	ppp->mru_alloc = PPP_MRU;
 	init_ppp_file(&ppp->file, INTERFACE);
 	ppp->file.hdrlen = PPP_HDRLEN - 2;	/* don't count proto bytes */
 	for (i = 0; i < NUM_NP; ++i)
